# (todo 未完成) CSS优先级，没你想的那么简单！全面介绍影响CSS优先级的属性

（todo 待选标题 CSS优先级，没你想的那么简单！选择器/类/继承/内联/默认样式/@layer/@import/important/:where()/动画/过渡等等... ）

## 目录
[[toc]]

## 简介
CSS的中文名称叫做“层叠样式表”。其中的层叠就是指的根据各类优先级规则来处理冲突的样式。因此层叠是CSS的一个重要特性，优先级也是CSS学习中一项非常重要的内容。

提到CSS优先级，我们首先会想到各类的选择器，例如ID选择器，类选择器，元素选择器等等。这些选择器有不同的优先级分数，可以根据得分轻松判断出CSS样式的优先级。

但是CSS优先级真的这么简单么？其实不是。在实践中，有很多很多会覆盖CSS样式或者改变优先级顺序的语法和现象，CSS优先级的判断实际上是非常复杂的。有如下这些主题会实际影响到CSS优先级的表现：

- CSS属性顺序
- 各种选择器和组合：ID选择器，类选择器，元素选择器等
- CSS属性继承
- 内联样式
- 层叠层 @layer
- 嵌套层叠层
- 浏览器默认样式
- 用户自定义样式
- !important声明
- CSS属性默认值
- 正在动画的样式
- 正在过渡的样式
- 引入样式 @import
- :where()和:is()和:not()选择器
- all属性

(todo 找更多的影响点, 这里待调整)

下面我们就来分别聊一下，这些主题是如何影响到CSS优先级的。

## CSS浏览器调试
在描述具体的优先级规则之前，我们先来看一下在页面上如何确定生效的是哪个CSS，以及如何调试CSS。

对于我们学习CSS优先级来说，在页面上如何确定生效的是哪个CSS是很容易的：我们只要设置一些非常明显的CSS样式即可，例如背景颜色，字体颜色等。不同的代码控制的颜色不同，即可很明显的看到是哪段代码生效。但是在实践中，有部分不容易直接观察到的CSS，或者有一定的触发条件，这时候使用浏览器调试功能，可以更方便的查看和调试CSS。

例如在Chrome浏览器中，我们在页面上右键点击想要查看的区域，选择检查，在调试面板中选择Elements，即可看到对应的HTML元素和CSS样式。

![](/2024/css-1.png)

在右侧的Style中，我们可以看到不同选择器的样式规则和生效情况，以及内联样式，甚至是用户代理样式（浏览器默认样式），和继承样式等，右侧还给出了代码来源。

![](/2024/css-2.png)

把鼠标放到选择器上，可以看到选择器具体的优先级数值。而那些画了删除线的样式，则是因为优先级低而不生效的样式。

![](/2024/css-3.png)

我们可以任意修改样式，查看效果，甚至可以新增或者删除样式。点击任意选择器，会出现新增属性的输入位置。点击任意属性，会发现属性key和值都可以变为编辑态。而且属性前会出现一个checkbox，取消勾中则该属性就不生效了。如果该属性恰好覆盖了其他属性，当取消勾中时，之前被覆盖属性的删除线会消失，属性变为生效状态。

![](/2024/css-4.png)

通过这些工具可以轻松的验证CSS属性的优先级和生效情况。当然，浏览器中CSS相关的调试工具还有很多，这里就不一一介绍了。

## CSS前后顺序
CSS属性顺序是一个很容易理解，但也很重要的一条规则。最所以最早描述，是因为这条规则影响着其他所有的规则。而且不仅适用于属性，也适用于选择器，layer，import等有先后顺序的CSS规则。(todo 哪些和先后顺序有关)

这条规则就是： 如果有多个CSS规则，且其他规则指定的优先级相同，则后面出现的规则比前面出现的规则优先级高。

例如：
```css
p {
  color: blue;
}
p {
  color: green;
  color: red;
}
```

同样的两个元素选择器，后面的优先级就比前面的高。而在一个选择器中，对同一个属性进行赋值，也是后面的优先级更高。因此，在上述的代码中， 优先级实际为：`red > green > blue`。查看浏览器，可以看到具体的生效样式。

![](/2024/css-5.png)

把red禁用后，也可以看到下一个生效的是green。

## 样式覆盖
虽然优先级比较的是选择器，但是每个样式属性是单独生效的，没有和其它选择器冲突的样式，并不会因为优先级低被覆盖。这里举个例子：

```css
p {
  color: blue;
  font-size: 10px;
}
p {
  color: green;
}
```
因为前后顺序，第二个选择器的优先级比第一个要高。这样第一个选择器是不是因为优先级低，所以里面的属性全都不生效？不是的。被覆盖的仅仅是高优先级选择器中被重复赋值的属性（在这个例子中是color），而没有被重复赋值的属性依然是生效的，（在这个例子中是font-size）。

## 各类选择器和组合
各类选择器和组合是我们平时接触最多的关于CSS优先级的内容。先来描述一下各种选择器的优先级。

### 选择器的优先级
选择器分为三个类别：

1. 元素选择器(`p`)和伪元素选择器(`::before`)
2. 类选择器(`.example`)，属性选择器(`[type="radio"]`)和伪类选择器(`:hover`)
3. ID选择器(`#example`)

在具体计算中，每一类选择器都对应一个权重分量：

他们的优先级是 第1类 < 第2类 < 第3类。对应的，优先级越高，实际上选择器越精确，例如ID选择器是唯一的，精确性最高。
类是开发者自己指定的，类选择器精确性一般比元素选择器要高。在具体计算中，每一类选择器都对应一个权重分量：

| 选择器类型 | 对应权重 |
| - | - |
| 元素选择器 | 0-0-1 |
| 类/属性选择器 | 0-1-0 |
| ID选择器 | 1-0-0 |

权重分量数值越大，表示优先级越高，例如 1-0-0 > 0-1-0 > 0-0-1。

### 组合选择器
假设一个选择器是由多个选择器组合而成的，那么这个选择器的优先级是其中各个选择器单独优先级的加和。不管使用哪种组合器甚至组合多层。（存在特殊情况，后面描述）例如：

| 选择器示例 | 组合器类型 | 包含选择器类型 | 对应权重和 |
| - | - | - | - |
| `#id` | 无 | 单个ID选择器 | 1-0-0 |
| `.a.b` | 交集选择器 | 两个类选择器 | 0-2-0 |
| `p>.a` | 直接子代选择器 | 元素选择器+类选择器 | 0-1-1 |
| `#id~.a [type="radio"]` | 兄弟组合器+后代组合器 | ID选择器+类选择器+属性选择器 | 1-2-0 |

通过计算单独选择器的加和，我们可以轻松的比较出各种选择器组合的优先级。可以看到，使用哪种组合选项器类型或者组合了多少层，都是不影响选择器的优先级的。

可以看到选择器权重和是相加的，那么会不会有进位现象呢？即：
- 0-0-12 是否等于 0-1-2
- 0-21-0 是否大于 2-0-0

答案都是否：没有进位规则；而且低优先级的选择器无论出现多少个，优先级也不会比高优先级的选择器更高。这里的权重和可以在Chrome浏览器中观察到（见**CSS浏览器调试**一节）。

### 特殊的选择器
有部分特殊的选择器类型，和上面介绍的规则并不一致，我们来看一下：

**通用选择器 `*`**
通用选择器是可以选择所有元素的选择器，优先级为 0-0-0。这个优先级比上面介绍的任何选择器的优先级更低。

**并集选择器 `.a, .b`**
并集选择器也是一种组合选择器，是一个由逗号分隔的选择器列表，例如`.a, .b, p`。如果其中任意选择器与元素匹配，这个选择器组合即与该元素匹配。它的优先级规则和其他组合选择器不同：是由选择器列表中生效的优先级最高的选择器决定该选择器的优先级。我们来看一个例子：

```html
<body>
  <p id="ida" class="a b c">hello, jzplp</p>
</body>
<style>
  p, #idb.a.b.c, .a, .b.c {
    color: blue;
  }
  #ida {
    color:red;
  }
</style>
```

对于body中的p元素分析下选择器的优先级情况。首先是`p, #idb.a.b.c, .a, .b.c`，我们把选择器列表拆开分析：

| 选择器 | 是否命中 | 权重和 |
| - | - | - |
| `p` | 是 | 0-0-1 |
| `#idb.a.b.c` | 否 | 1-3-0 |
| `.a` | 是 | 0-1-0 |
| `.b.c` | 是 | 0-2-0 |

然后是`#ida`选择器，成功命中，权重和为1-0-0。我们把这段代码放到浏览器中，可以看到生效的是`#ida`选择器。

![](/2024/css-6.png)

虽然并集选择器中优先级最高的为1-3-0，比`#ida`选择器更高，但在没命中的情况下并不生效，选择器优先级是在生效的情况下比较。

### CSS嵌套
样式嵌套常见于各类CSS预处理器，比如LESS和SCSS等等。到后来CSS本身也有了CSS嵌套(CSS nesting)，目前较新的浏览器版本才支持:

![](/2024/css-9.png)

但是CSS嵌套虽然形式上写法不一样了，但实际上仅仅是语法糖，本质上并没有增加新的选择器，例如：
```css
/*（1）*/
.a {
  color: red;
  .b {
    color: blue;
  }
}
/*（1）相当于：*/
.a {
  color: red;
}
.a .b {
  color: blue;
}

/*（2）*/
.a {
  > .b {
    color: blue;
  }
}
/*（2）相当于：*/
.a > .b {
  color: blue;
}

/*（3）*/
.a {
  .b + & {
    color: blue;
  }
}
/*（3）相当于：*/
.b + .a {
  color: blue;
}
```

因此，我们还是可以利用上面的优先级计算方法来计算CSS嵌套中各层的优先级。

### 总结
通过上面的描述，我们已经知道了基础的优先级比较原则，即根据权重和计算和比较得出。为什么这么设计，实际是遵循了一个原则：选择器越“精确”，优先级越高。这个原则不仅适用于上面的内容，对于后面提到的更多优先级规则也适用。

## 伪类
### 普通伪类
伪类有函数式伪类和非函数式伪类，我们先来说一下非函数式伪类。非函数式伪类与其他选择器一样，也有着优先级权重。权重为： 0-1-0。这些选择器例如：`:root`, `:empty`, `:link` 等等。

### 接收非选择器的函数式伪类
有好多个函数式伪类，函数参数接受的是非选择器形式的伪类，比如：`:dir(ltr)`, `:lang(en-US)`, `:nth-child(1)`等等。这些伪类与普通伪类一样，优先级权重为： 0-1-0。

### `:is()`伪类
`:is()` 接受一个可容错的选择器列表，例如`:is(p, .a, #b)`。如果列表中任意选择器命中，则该伪类命中。这个伪类的作用与并集选择器类似，但是优先级规则却不一样：

* 并集选择器的优先级为：列表中生效的优先级最高的选择器
* `:is()`的优先级为：列表中优先级最高的选择器

区别是，即使列表中最高优先级的选择器没有生效，`:is()`依然会使用它作为优先级。这里举个例子：

```html
<html>
  <body>
    <p id="ida" class="a b c">hello, jzplp</p>
  </body>
  <style>
    :is(.a.b.c, #idb.a.b, p) {
      color: red;
    }
    #ida {
      color: blue;
    }
  </style>
</html>
```

我们计算下其中出现的选择器权重和：

| 选择器 | 是否命中 | 权重和 |
| - | - | - |
| `.a.b.c` | 是 | 0-3-0 |
| `#idb.a.b` | 否 | 1-2-0 |
| `p` | 是 | 0-0-1 |
| `#ida` | 是 | 1-0-0 |
| `:is(.a.b.c, #idb.a.b, p)` | 是 | 1-2-0 |

可以看到，`:is()`中优先级最高的选择器`#idb.a.b`并未命中，可是`:is(.a.b.c, #idb.a.b, p)`依然选择了这个未命中的选择器作为其权重和。在浏览器中执行也可以验证效果：（可以看到权重和1-0-0的选择器`#ida`未生效）

![](/2024/css-7.png)

###  `:not()`伪类
`:not()`接受一个选择器列表，例如`:not(p, .a, #b)`。如果列表中的选择器都没有被命中，则该伪类命中。在命中的情况下，`:not()`优先级为选择器列表中优先级最高的一个选择器。

在实践中有时候会利用这个特性提高选择器的优先级：
* 原选择器 `.a` 优先级 0-1-0
* 提高后选择器 `.a:not(#anyAbsentID)` 优先级 1-1-0

我们取一个页面中并不存在的id（或者其他并不存在但是优先级高的选择器），作为`:not()`的参数，再和原选择器进行组合，即可提高原选择器的优先级，但是实际命中的元素相同。

### `:has()`伪类
`:has()`接受一个相对选择器列表，如果列表中任意选择器命中，则该伪类命中。这个“相对选择器”，实际上就是组合选择器去掉了前面的元素，因此这个伪类的形式类似于`p:has(+.a, +.b)`。意思是如果`p+.a`或者`p+.b`，命中，则该选择器命中。但是它与`:is(p+.a, p+.b)`的不同点在于，名中后样式生效的元素不一样：
* `:is(p+.a, p+.b)` 样式生效的选择器为`p`后面的`.a`或`.b`。
* `p:has(+.a, +.b)` 样式生效的选择器为`p`本身，不是后面的`.a`或`.b`。

也就是说，`:has()`仅仅是提供了一个限制条件，真正样式生效的元素还是`:has()`前的选择器。我们还是举个例子来看：

```html
<html>
  <body>
    <div>
      <p id="ida">123</p>
      <p class="a b c">hello, jzplp</p>
    </div>
  </body>
  <style>
    p:has(+.a.b.c, +#idb.a.b, +p) {
      color: red;
    }
    :is(p+.a.b.c, p+#idb.a.b, p+p) {
      color: yellow;
    }
    #ida {
      color: blue;
    }
  </style>
</html>
```

例子中`p:has(+.a.b.c, +#idb.a.b, +p)`和`:is(p+.a.b.c, p+#idb.a.b, p+p)`实际的命中规则相同，命中的都是第一个和第二个p元素的组合。但是生效元素不同。（其中真正对于命中起作用的是`p+.a.b.c`）
* `p:has(+.a.b.c, +#idb.a.b, +p)` 实际生效元素是`<p id="ida">123</p>`
* `:is(p+.a.b.c, p+#idb.a.b, p+p)` 实际生效元素是`<p class="a b c">hello, jzplp</p>`

![](/2024/css-8.png)

通过上面的例子，也可以看到`:has()`的优先级判断规则与`:is()`是一致的：选择列表中优先级最高的选择器作为其优先级。

`p:has(+.a.b.c, +#idb.a.b, +p)`与`#ida`生效的都是`<p id="ida">123</p>`元素。虽然`:has()`中的`+#idb.a.b`没有命中，但还是用它的1-2-0作为优先级权重和，与`p`组合后为1-2-1，大于`#ida`的1-0-0。因此在例子中`#ida`被覆盖了。

### `:where()`伪类
`:where()`同样是一个函数式伪类，也接受一个选择器列表做入参，而且用法和`:is()`一样，列表中的任意选择器命中，则该伪类命中。

但是它的优先级规则和`:is()`却不一样：`:where()`一直是0-0-0，不管其中的选择器列表的优先级如何。

## 伪元素

### 伪元素的优先级
伪元素在MDN和其他资料中描述的优先级都是 0-0-1。但是我在Chrome浏览器中查看优先级，却不是这样的：

![](/2024/css-10.png)

通过调试，发现`::after`伪元素的优先级是 0-1-0，而不是0-0-1。不仅`::after`，其它伪元素的优先级也是如此。

### 伪元素的实际优先效果
我们再来看看，伪元素的实际优先效果。先举个例子：
```html
<html>
  <body>
      <p>hello, jzplp</p>
  </body>
  <style>
    ::after {
      content: 'value';
      color: red;
    }
    :not(#ida) {
      color: blue;
    }
  </style>
</html>
```
p元素内部生成了一个`::after`伪元素，同时也命中了`:not(#ida)`，且优先级为1-0-0，比伪元素要高。但是查看实际效果，却发现`::after`的内容实际为命中，仅p标签本身命中了：

![](/2024/css-11.png)

通过浏览器调试可以看到，`:not(#ida)`被当成了继承于p元素的样式属性，而不是`::after`自己的属性。虽然`::after`实际上是p标签内部的元素，且`:not(#ida)`在这个场景下是可以命中任何元素的，但是`::after`把它作为了继承而没有生效。

那我们再举一个无法作为继承，确实可以命中选择器的伪元素`::first-line`作为例子：
```html
<html>
  <body>
      <p>hello, jzplp</p>
  </body>
  <style>
    ::first-line { color: red; }
    :not(#ida) { color: blue; }
  </style>
</html>
```
这里根据浏览器调试栏的结果，`:not(#ida)`的优先级为1-0-0，`::first-line`的优先级为0-1-0，都命中了p元素。且`:not(#ida)`没被作为继承，也没有被划去。但是这时候，生效的却是优先级更低的`::first-line`。

![](/2024/css-12.png)

这时候我们再换种测试方式：

```html
<html>
  <body>
      <p class="pp"><span class="sss">hello</span>, jzplp</p>
  </body>
  <style>
    .pp::first-line { color: red; }
    span { color: green; }
  </style>
</html>
```

`.pp::first-line`的优先级毫无疑问比`span`优先级高，但是这时候`span`中的元素却是绿色，没有被更高优先级的覆盖。`span`元素之外的文字却是红色的，说明伪元素是生效的。

这说明，虽然伪元素表面上优先级不高，但在伪元素的“作用范围内”却可能将优先级更高的样式覆盖掉。我们对待伪元素，不能像对待普通选择器那样比较优先级，而是应该具体问题具体分析。

## 内联样式
上面我们介绍的各类CSS，都是写在单独的`<style>`元素中的，作为选择器对HTML元素进行匹配的，叫做“内部样式表”但是还有一种CSS写法，不需要匹配HTML元素，而是直接在HTML元素上作为style属性出现，这就是内联样式，也叫做行内样式。

由于内联样式不需要匹配，所以在“精确度”上是高于各种选择器的，因此优先级也比“内部样式表”更高。看一个例子：

```html
<html>
  <body>
    <p id="idp" style="color: blue">hello, jzplp</p>
  </body>
  <style>
    #idp { color: red; }
  </style>
</html>
```

虽然`#idp`选择器的优先级是1-0-0，但是依然不如style属性优先级更高。内联样式在Chrome的调试栏中作为`element.style`出现：

![](/2024/css-13.png)

## 继承属性
在CSS中存在父元素的属性可以被子元素继承的规则，分为默认继承和主动继承，这里分别介绍一下。

### 默认继承
#### 继承规则
默认继承指的是需要我们说主动声明继承关系或者操作什么，这是CSS的默认行为。我们来看一个例子：

```html
<html>
  <body>
    <p id="idp"><span>hello, jzplp</span></p>
  </body>
  <style>
    #idp { color: red; }
  </style>
</html>
```
`<span>`的父元素为`<p>`，虽然`<span>`本身并没有设置颜色，但是父元素设置了颜色，因此`<span>`继承了父元素的红色。在Chrome浏览器的调试栏中，`Inherited from XXX` 就表示该属性继承于元素XXX。

![](/2024/css-14.png)

同时继承也是可以一层一层传递的。我们再来看一个例子：
```html
<html>
  <body>
    <div id="idp">
      <p><span>hello, jzplp</span></p>
    </div>
  </body>
  <style>
    #idp {
      color: red;
    }
  </style>
</html>
```

`<span>`以及它的父元素`<p>`都没有color，但是更上层的`<div>`定义了，因此`<div>`继承给`<p>`，`<p>`再继承给`<span>`，因此`<span>`中的内容也是红色。

#### 仅部分属性默认继承
并不是所有的属性都会被默认继承，而是只有部分属性存在继承现象。这里举几个例子：

* 默认继承的属性：color, font-size, text-align, visibility 等等。
* 不默认继承的属性：background-color, height, width, overflow, opacity 等等。

属性是否默认继承是由CSS规则决定的，背后的原因是希望CSS在默认情况下使用方便一些：
>  一些属性是不能继承的 —— 举个例子如果你在一个元素上设置width为50%，所有的后代不会是父元素的宽度的50%。如果这个也可以继承的话，CSS就会很难使用了！

#### 默认继承的优先级
默认继承的优先级，仅在继承元素未设置该CSS属性时生效，一旦设置了属性，无论权重和高低，优先级都比继承的要高。这个也非常好理解：继承而来的属性，在“精确性”上肯定不如明确设置的属性要高。我们看个例子：

```html
<html>
  <body>
    <div id="idp"> <span>hello, jzplp</span> </div>
  </body>
  <style>
    span { color: blue; }
    #idp { color: red; }
  </style>
</html>
```
`#idp`的优先级为1-0-0，由div继承给了span。span自己命中的选择器权重和只有0-0-1，可是依然生效了，优先级比任何继承属性都要高。

![](/2024/css-15.png)

当然，如果父元素就存在CSS样式优先级竞争的情况，那么父元素优先级最高的，也就是父元素生效的属性才会被继承。即自己内部先决出胜负再说。

### 显式继承
由上面默认继承的部分可知，仅有部分CSS属性可以默认继承，而且继承的优先级是比较低的。那么如果我们希望提高继承的优先级，或者希望继承那些没有默认继承的属性呢？这时候就需要显式继承了。





## 浏览器默认样式

## 样式初始值

## all属性

## !important声明

## 外部样式表

## @import

## 用户自定义样式

## 层叠层 @layer

## 嵌套层叠层

## 其他不会影响CSS优先级的内容
todo 元素接近度
todo class 顺序



## 参考
- MDN CSS优先级\
  https://developer.mozilla.org/zh-CN/docs/Web/CSS/Specificity
- MDN CSS层叠、优先级与继承\
  https://developer.mozilla.org/zh-CN/docs/Learn/CSS/Building_blocks/Cascade_and_inheritance
- MDN CSS层叠层\
  https://developer.mozilla.org/zh-CN/docs/Learn/CSS/Building_blocks/Cascade_layers
- CSS specifishity with plankton, fish and sharks\
  https://specifishity.com/
- CSS中class的优先级\
  https://blog.csdn.net/yjjjjz/article/details/103240864
- MDN CSS 选择器\
  https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_selectors
- MDN CSS 伪类\
  https://developer.mozilla.org/zh-CN/docs/Web/CSS/Pseudo-classes
- MDN CSS 伪元素\
  https://developer.mozilla.org/zh-CN/docs/Web/CSS/Pseudo-elements
- MDN CSS all属性\
  https://developer.mozilla.org/zh-CN/docs/Web/CSS/all
- MDN CSS :is()伪类\
  https://developer.mozilla.org/zh-CN/docs/Web/CSS/:is
- MDN CSS :not()伪类\
  https://developer.mozilla.org/zh-CN/docs/Web/CSS/:not
- MDN CSS :has()伪类\
  https://developer.mozilla.org/zh-CN/docs/Web/CSS/:has
- MDN CSS :where()伪类\
  https://developer.mozilla.org/zh-CN/docs/Web/CSS/:where
- MDN CSS 嵌套\
  https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_nesting
- MDN CSS 继承\
  https://developer.mozilla.org/zh-CN/docs/Web/CSS/Inheritance
- MDN CSS inherit\
  https://developer.mozilla.org/zh-CN/docs/Web/CSS/inherit
